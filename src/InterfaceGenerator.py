#!/usr/bin/python3

# Python script to automatically generate the interface, since it is filled with boilerplate code

FPTypes = ["float", "double", "longdouble"]
MaxVectorSize = {'float': 16, 'double': 8, 'longdouble': 4}
ShadowType = ["OpaqueShadow", "OpaqueLargeShadow"]


def GetVectorPrefix(VSize=1):
    if (VSize == 1):
        return ""
    return "v" + str(VSize)


def TypeToMetaFloat(Type: str, VSize=1):
    if Type == "longdouble" :
        Type = "long double"
    return f"MetaFloat<{Type}, {VSize}>"
    if Type == "longdouble":
        if VSize == 1:
            return "long double"
        return GetVectorPrefix(VSize) + "ldouble"
    return GetVectorPrefix(VSize) + Type
    
def MetaFloatToFpType(Type: str) :
    return f"{Type}::FPType"

def FPTypeToShadow(Type: str, VSize=1):
    ShadowType = "OpaqueShadow" if Type == "float" else "OpaqueLargeShadow"
    return GetVectorPrefix(VSize) + ShadowType + ("*" if VSize == 1 else "")


def FPPrefix(Type: str, VSize=1):
    res = "__interflop_" + Type

    if VSize > 1:
        res += "_" + GetVectorPrefix(VSize)
    return res


def WriteHeader(File=None):
    File.write(
        "// This file was automatically generated by InterfaceGenerator.py\n")
    File.write("// Caution: Any changes made to this file will be erased\n\n")
    File.write("#include \"Context.hpp\"\n\n")
    File.write("#include <cstring>\n")
    File.write("using namespace interflop;\n")
    File.write("template <typename T> using Backend = InterflopBackend<T>;\n\n")

def GenerateHelperFunction(File=None):
    # Helper function to reduce a vector of bool to a single bool
    File.write("namespace {"
               "template < typename ScalarT, typename VectorT >\n"
               "bool ReducePredicate(VectorT Vec) {\n"
               "\tconstexpr size_t Size = sizeof(VectorT) / sizeof(ScalarT);\n"
               "\tbool Res = true;\n"
               "\tfor (int I=0; Res && (I < Size); I++)\n"
               "\t\tRes = Res && Vec[I];\n"
               "\treturn Res;\n"
               "}\n"
               "} // namespace\n\n")


def GenerateConstructor(Type: str, VSize=1, File=None):
    MetaFloat = TypeToMetaFloat(Type, VSize)
    CType = MetaFloatToFpType(MetaFloat)
    ShadowType = FPTypeToShadow(Type, VSize)
    Prefix = FPPrefix(Type, VSize)
    File.write(
        f"extern \"C\" void {Prefix}_make_shadow({CType} a, {ShadowType} sa)")
    File.write(" {\n")
    File.write(f"\tBackend<{MetaFloat}> Backend;\n")
    if VSize == 1:
        File.write(f"\tBackend.MakeShadow(a, &sa);\n")
    else:
        File.write(f"\tBackend.MakeShadow(a, sa);\n")
    File.write("}\n\n")


def GenerateUnary(Type: str, VSize=1, File=None):
    MetaFloat = TypeToMetaFloat(Type, VSize)
    CType = MetaFloatToFpType(MetaFloat)
    ShadowType = FPTypeToShadow(Type, VSize)
    Prefix = FPPrefix(Type, VSize)
    File.write(
        f"extern \"C\" {CType} {Prefix}_neg({CType} a, {ShadowType} sa, {ShadowType} res)")
    File.write(" {\n")
    File.write(f"\tBackend<{MetaFloat}> Backend;\n")
    if VSize == 1:
        File.write(f"\treturn Backend.Neg(a, &sa, &res);\n")
    else:
        File.write(f"\treturn Backend.Neg(a, sa, res);\n")
    File.write("}\n\n")


def GenerateBinary(Type: str, VSize=1, File=None):
    BinaryOps = ["add", "sub", "mul", "div"]
    MetaFloat = TypeToMetaFloat(Type, VSize)
    CType = MetaFloatToFpType(MetaFloat)
    ShadowType = FPTypeToShadow(Type, VSize)
    Prefix = FPPrefix(Type, VSize)
    for Op in BinaryOps:
        File.write(
            f"extern \"C\" {CType} {Prefix}_f{Op}({CType} a, {ShadowType} sa, {CType} b, {ShadowType} sb, {ShadowType} res)")
        File.write(" {\n")
        File.write(f"\tBackend<{MetaFloat}> Backend;\n")
        Op = Op.capitalize()
        if VSize == 1:
            File.write(f"\treturn Backend.{Op}(a, &sa, b, &sb, &res);\n")
        else:
            File.write(f"\treturn Backend.{Op}(a, sa, b, sb, res);\n")
        File.write("}\n\n")


def GenerateCheck(Type: str, File):
    BinaryOps = ["add", "sub", "mul", "div"]
    MetaFloat = TypeToMetaFloat(Type, 1)
    CType = MetaFloatToFpType(MetaFloat)
    ShadowType = FPTypeToShadow(Type)
    Prefix = FPPrefix(Type)

    File.write(
        f"extern \"C\" int {Prefix}_check({CType} a, {ShadowType} sa)")
    File.write(" {\n")
    File.write(f"\tBackend<{MetaFloat}> Backend;\n")
    File.write(f"\treturn Backend.Check(a, &sa);\n")
    File.write("}\n\n")


def GenerateFCmpCheck(Type: str, VSize: int, File):
    FCmpOps = ["oeq", "one", "ogt", "oge", "olt",
               "ole", "ueq", "une", "ugt", "uge", "ult", "ule"]
    CmpOps = {"eq": "==", "ne": "!=", "gt": ">",
              "ge": ">=", "lt": "<", "le": "<="}
    MetaFloat = TypeToMetaFloat(Type, VSize)
    CType = MetaFloatToFpType(MetaFloat)
    ShadowType = FPTypeToShadow(Type, VSize)
    Prefix = FPPrefix(Type, VSize)

    for Op in FCmpOps:
        File.write(
            f"extern \"C\" int {Prefix}_fcmp_{Op}({CType} a, {ShadowType} sa, {CType} b, {ShadowType} sb)")
        File.write(" {\n")
        File.write(f"\tBackend<{MetaFloat}> Backend;\n")
        if VSize == 1:
            File.write(
                f"\treturn Backend.CheckFCmp(FCmp_{Op}, a, &sa, b, &sb, a {CmpOps[Op[1:]]} b);\n")
        else:
            File.write(
                f"\treturn Backend.CheckFCmp(FCmp_{Op}, a, sa, b, sb, ReducePredicate<{CType}>(a {CmpOps[Op[1:]]} b));\n")
        File.write("}\n\n")


def GenerateCast(Type: str, VSize: int, File=None):
    MetaFloat = TypeToMetaFloat(Type, VSize)
    CType = MetaFloatToFpType(MetaFloat)
    ShadowType = FPTypeToShadow(Type, VSize)
    Prefix = FPPrefix(Type, VSize)
    Casts = {"float": "CastToFloat", "double": "CastToDouble",
             "longdouble": "CastToLongdouble"}

    for DestType in FPTypes:
        if DestType == Type or VSize > MaxVectorSize[DestType]:
            continue
        ShadowDestType = FPTypeToShadow(DestType, VSize)
        Cast = "DownCast" if DestType == "float" else "UpCast"
        File.write(
            f"extern \"C\" void {Prefix}_{DestType}_cast({CType} a, {ShadowType} sa, {ShadowDestType} res)")
        File.write(" {\n")
        File.write(f"\tBackend<{MetaFloat}> Backend;\n")
        if VSize == 1:
            File.write(
                f"\tBackend.{Casts[DestType]}(a, &sa, &res);\n")
        else:
            File.write(
                f"\tBackend.{Casts[DestType]}(a, sa, res);\n")
        File.write("}\n\n")


def GenerateInterface():
    File = open("Interface.cpp", "w")
    WriteHeader(File)
    GenerateHelperFunction(File)
    for Type in FPTypes:
        VSize = 1
        GenerateCheck(Type, File)
        while VSize <= MaxVectorSize[Type]:
            GenerateConstructor(Type, VSize, File)
            GenerateUnary(Type, VSize, File)
            GenerateBinary(Type, VSize, File)
            GenerateFCmpCheck(Type, VSize, File)
            GenerateCast(Type, VSize, File)
            VSize *= 2


GenerateInterface()
