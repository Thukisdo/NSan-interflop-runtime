#include "backends/MCASync.hpp"
#include <filesystem>
#include <fstream>
#include <gtest/gtest.h>
#include <iomanip>
#include <iostream>

constexpr size_t N_SAMPLE = 1000;
constexpr float RANDOM_FLOAT = 0.13f;

using namespace interflop::mcasync;

// Helper methods to generate samples and calculate the ratio between the two
// values generated by StochasticRound on a given input
void Sample(float Input, std::array<float, N_SAMPLE> &Buffer,
            std::unordered_map<float, size_t> &Counts) {
  for (int I = 0; I < N_SAMPLE; ++I)
    Buffer[I] = StochasticRound((double)Input);

  for (int I = 0; I < N_SAMPLE; ++I)
    Counts[Buffer[I]]++;
}

float CalcSampleRatio(float X) {
  std::array<float, N_SAMPLE> Buffer;
  std::unordered_map<float, size_t> Counts;
  Sample(X, Buffer, Counts);
  
  if (Counts.size() != 2)
  {
    throw std::runtime_error("Unexpected number of samples");
  }

  auto It = Counts.begin();
  float N1 = It->second;
  float N2 = (++It)->second;
  return N1 / (N1 + N2);
}

// Check that stochastic round produces exactly two possible results for a given
// input
TEST(MCASync, RoundProducesTwoValues) {
  std::array<float, N_SAMPLE> Buffer;
  std::unordered_map<float, size_t> Counts;
  Sample(1.0f, Buffer, Counts);
  EXPECT_EQ(Counts.size(), 2);
}

// Check that StochasticRound is in range [x, x + ulp(x)]
TEST(MCASync, RoundUlp) {
  std::array<float, N_SAMPLE> Buffer;
  std::unordered_map<float, size_t> Counts;
  Sample(1.0f, Buffer, Counts);

  auto It = Counts.begin();
  float N1 = (It)->first;
  float N2 = (++It)->first;

  float Max = std::max(N1, N2);
  float Min = std::min(N1, N2);
  EXPECT_EQ(Max, std::nextafterf(1.0f, 2.0f));
  EXPECT_EQ(Min, 1.0f);
}

// Check that stochastic round produces an even distribution of the possible
// values with a random float
TEST(MCASync, RoundRandomFloat) {
  EXPECT_NEAR(CalcSampleRatio(RANDOM_FLOAT), 0.5f, 0.05f);
}

// Check that stochastic round produces an even distribution of the possible
// values with a random float
TEST(MCASync, RoundOne) { EXPECT_NEAR(CalcSampleRatio(1.0f), 0.5f, 0.05f); }

TEST(MCASync, RoundInfinite) {
  constexpr float Infinite = std::numeric_limits<float>::infinity();
  float X = StochasticRound(Infinite);
  EXPECT_TRUE(std::isnan(X));
}

TEST(MCASync, RoundNan) {
  constexpr float NaN = std::numeric_limits<float>::quiet_NaN();
  float X = StochasticRound(NaN);
  EXPECT_TRUE(std::isnan(X));
}

#if FLT_HAS_SUBNORM

TEST(MCASync, RoundSubnormal) {
  uint32_t bytes = 0x7FF0FF;
  float subnormal = *(float *)&bytes;

  EXPECT_NEAR(CalcSampleRatio(subnormal), 0.5f, 0.01f);
}

#endif