#include "backends/MCASync.hpp"
#include <filesystem>
#include <fstream>
#include <gtest/gtest.h>
#include <iomanip>
#include <iostream>

constexpr size_t N_SAMPLE = 1000;
constexpr float RANDOM_FLOAT = 0.13f;

using namespace interflop;

// Helper methods to generate samples and calculate the ratio between the two
// values generated by StochasticRound on a given input
void Sample(float input, std::array<float, N_SAMPLE> &buffer,
            std::unordered_map<float, size_t> &counts) {
  for (int I = 0; I < N_SAMPLE; ++I)
    buffer[I] = interflop::StochasticRound((double)input);

  for (int I = 0; I < N_SAMPLE; ++I)
    counts[buffer[I]]++;
}

float CalcSampleRatio(float x) {
  std::array<float, N_SAMPLE> buffer;
  std::unordered_map<float, size_t> counts;
  Sample(x, buffer, counts);

  auto It = counts.begin();
  float n1 = It->second;
  float n2 = ++It->second;
  return n1 / (n1 + n2);
}

// Check that stochastic round produces exactly two possible results for a given
// input
TEST(MCASync, StochasticRoundProducesTwoValues) {
  std::array<float, N_SAMPLE> buffer;
  std::unordered_map<float, size_t> counts;
  Sample(1.0f, buffer, counts);
  EXPECT_EQ(counts.size(), 2);
}

// Check that stochastic round produces an even distribution of the possible
// values with a random float
TEST(MCASync, StochasticRoundRandomFloat) {
  EXPECT_NEAR(CalcSampleRatio(RANDOM_FLOAT), 0.5f, 0.025f);
}

// Check that stochastic round produces an even distribution of the possible
// values with a random float
TEST(MCASync, StochasticRoundOne) {
  EXPECT_NEAR(CalcSampleRatio(1.0f), 0.5f, 0.025f);
}

// Check that StochasticRound is in range [x, x + ulp(x)]
TEST(MCASync, StochasticRoundUlp) {
  std::array<float, N_SAMPLE> buffer;
  std::unordered_map<float, size_t> counts;
  Sample(1.0f, buffer, counts);

  auto It = counts.begin();
  float n1 = (It)->first;
  float n2 = (++It)->first;

  float max = std::max(n1, n2);
  float min = std::min(n1, n2);
  EXPECT_EQ(max, std::nextafterf(1.0f, 2.0f));
  EXPECT_EQ(min, 1.0f);
}